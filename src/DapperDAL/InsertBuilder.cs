namespace DapperDAL;

public static class InsertBuilder<T> where T : class
{
    /// <summary>
    /// Builds the INSERT statment which goes into a insert string.
    /// The form will be INSERT INTO [TABLENAME] ([DbColumnName], ...) OUTPUT (...) VALUES(@...).
    /// Note: rarely should this be used directly, instead use BuilderCache<T>.InsertStatement for the cached value;
    /// </summary>
    /// <returns></returns>
    public static string BuildInsertStatement()
    {
        StringBuilder sb = new StringBuilder();

        var tableattr = typeof(T).GetCustomAttributes(true).SingleOrDefault(attr =>
            attr.GetType().Name == typeof(TableAttribute).Name) as dynamic;
        string? alias = tableattr?.Alias;

        sb.Append("INSERT INTO ");
        sb.Append(BuilderCache<T>.TableName);
        sb.Append('(');
        BuildInsertColumns(sb, alias);
        sb.Append(") ");
        BuildOutputStatement(sb, alias);
        sb.Append(" VALUES (");
        BuildInsertValues(sb);
        sb.Append(')');

        return sb.ToString();
    }

    public static void BuildInsertColumns(StringBuilder sb, string? alias = null)
    {

        bool first = true;
        foreach (var property in BuilderCache<T>.ScaffoldProperties)
        {
            if (!CanUseProperty(property))
                continue;

            if (!first)
                sb.Append(", ");
            first = false;

            sb.Append(Resolvers.ResolveColumnName(property, alias));
        }
    }

    public static void BuildInsertValues(StringBuilder sb)
    {
        bool first = true;
        foreach (var property in BuilderCache<T>.ScaffoldProperties)
        {
            if (!CanUseProperty(property))
                continue;

            if (!first)
                sb.Append(", ");
            first = false;

            sb.Append('@');
            sb.Append(property.Name);
        }
    }

    public static void BuildOutputStatement(StringBuilder sb, string? alias = null)
    {
        var outputProperties = BuilderCache<T>.ScaffoldProperties.Where(p => p.PropertyType != typeof(string) &&
              p.GetCustomAttributes(true).Any(attr => (attr.GetType().Name == typeof(KeyAttribute).Name) || 
                                             (attr.GetType().Name == typeof(NonAutoKeyAttribute).Name)));

        if (!outputProperties.Any())
            return;

        sb.Append("OUTPUT ");
        bool first = true;
        foreach (var property in outputProperties)
        {
            if (!first)
                sb.Append(", ");
            first = false;

            sb.Append("INSERTED.");
            sb.Append(Resolvers.ResolveColumnName(property, alias));
        }
    }

    public static bool CanUseProperty(PropertyInfo property)
    {
        // do not use id, Id or ID
        if (property.Name.Equals("Id", StringComparison.OrdinalIgnoreCase))
            return false;

        // do not use if it has a [Key] attribute unless it's a string or or has a [Required} attribute
        // this will ensure that autogenerated ids are respected
        if (property.PropertyType != typeof(string) &&
              property.GetCustomAttributes(true).Any(attr => attr.GetType().Name == typeof(KeyAttribute).Name) &&
              property.GetCustomAttributes(true).All(attr => attr.GetType().Name != typeof(RequiredAttribute).Name))
            return false;

        // do not use if [IgnoreInsert], [NotMapped] or [ReadOnly] attributes used
        if (property.GetCustomAttributes(true).Any(attr =>
                attr.GetType().Name == typeof(IgnoreInsertAttribute).Name ||
                attr.GetType().Name == typeof(NotMappedAttribute).Name ||
                attr.GetType().Name == typeof(ReadOnlyAttribute).Name &&
                PropertiesHelper.IsReadOnly(property)))
            return false;

        return true;
    }
}
